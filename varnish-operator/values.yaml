# namespace should match the Namespace created in the Getting Access section of the README.md
namespace: varnish-service-system
# this field should not be changed
namePrefix: varnish-service-

operator:
  # logging level: "debug", "info", "warn", "error"
  logLevel: info
  # logging encoder: "json", "console"
  logFormat: json

  varnishImage:
    # Use the name of the imagePullSecret created in the [Getting Access](#getting-access) section above
    imagePullSecretName: docker-reg-secret

    # The host, namespace, name, and tag make up the path used to pull the varnish image, with the form "$host/$namespace/$name:$tag"

    # You might modify the host to be the nearest instance of container registry to the cluster
    host: registry.ng.bluemix.net
    # If you decide to host the varnish image yourself, you may need to change the image namespace or name
    # Note, however, that you cannot use any old version of varnish -- the official image has a sidecar process that monitors the kubernetes API
    namespace: icm-varnish
    name: varnish
    # You might specify a tag version to ensure that you control the lifecycle of what version of varnish is deployed
    tag: 2.0.0
    # pullPolicy is passed directly to the varnish deployment, that controls how the varnish image will be pulled for new containers
    pullPolicy: Always
  controllerImage:
    # Use the name of the imagePullSecret created in the [Getting Access](#getting-access) section above
    imagePullSecretName: docker-reg-secret

    # The host, namespace, name, and tag make up the path used to pull the varnish image, with the form "$host/$namespace/$name:$tag"

    # You might modify the host to be the nearest instance of container registry to the cluster
    host: registry.ng.bluemix.net
    # If you decide to host the varnish image yourself, you may need to change the image namespace or name
    # Note, however, that you cannot use any old version of varnish -- the official image has a sidecar process that monitors the kubernetes API
    namespace: icm-varnish
    name: varnish-controller
    # You might specify a tag version to ensure that you control the lifecycle of what version of varnish is deployed
    tag: 0.2.0
    # pullPolicy is passed directly to the varnish deployment, that controls how the varnish image will be pulled for new containers
    pullPolicy: Always
  # specifies the pod count of the Manager. Right now, the only valid value is 1
  replicas: 1
  # it is unlikely you will need to change the resources values of the operator
  resources:
    limits:
      cpu: 100m
      memory: 30Mi
    requests:
      cpu: 100m
      memory: 20Mi

varnish:
  # there should not be much reason to change any of these port values
  port: 2035
  targetPort: 2035
  exporterPort: 9131
  # Warning: without modifying the Docker image, changing exporterTargetPort will break metrics
  exporterTargetPort: 9131

# the default section describes all of the defaults available for the VarnishService CustomResource.
default:
  vclConfigMap:
    # the name given to the configMap that contains the contents of the vcl. If the configMap does not exist, a basic round-robin-based VCL file will be created and used
    # MUST use only lowercase letters, numbers, "-", or "."
    name: vcl-file
    # the name of the file to be maintained through the Kubernetes API (by watching the endpoints in a deployment)
    # the VarnishService will expect to see a "<backendsFile>.tmpl" file in the ConfigMap that has the Go template for the <backendsFile>. For example, "backends.vcl.tmpl"
    backendsFile: backends.vcl
    # the name of the base VCL file
    defaultFile: default.vcl
  deployment:
    # The amount of memory allocated to Varnish on Varnish's startup, in the form of `varnishd -F -s malloc,${varnishMemory} ...`
    varnishMemory: 1024M
    # Resources allocated to the Varnish pod through Kubernetes. `requests.memory` Should be greater than `varnishMemory` above
    varnishResources:
      limits:
        cpu: 1
        memory: 2048Mi
      requests:
        cpu: 1
        memory: 2048Mi
    # restart policy used for Varnish containers
    varnishRestartPolicy: Always
    # http path used to confirm liveness of the Varnish container. TODO: Not currently working
    # livenessProbe:
    #   httpPath: /liveness
    #   port: 8080
    # command used to confirm readiness of the Varnish container. Unlikely to need to be changed
    readinessProbe:
      command: /usr/bin/varnishadm,ping
