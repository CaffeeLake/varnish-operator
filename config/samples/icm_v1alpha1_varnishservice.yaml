# the apiVersion will almost never change
apiVersion: icm.ibm.com/v1alpha1
# VarnishResource can now be a Kind thanks to adding it as a CustomResource
kind: VarnishService
metadata:
  # Add any labels you think will help
  labels:
    operator: varnish
  # any name is fine
  name: varnishservice-sample
  # the namespace must have the docker registry secret used by the operator in it
  namespace: varnish-ns
# The spec is divided into 2 parts: the deployment portion and the service portion
# The deployment portion has all of the details for the actual Varnish deployment
# The service portion is literally the exact same spec as a regular Service resource
spec:
  vclConfigMap:
    # the name given to the configMap that contains the contents of the vcl. If the configMap does not exist, a basic round-robin-based VCL file will be created and used
    # MUST use only lowercase letters, numbers, "-", or "."
    name: vcl-file
    # the name of the file to be maintained through the Kubernetes API (by watching the endpoints in a deployment)
    # the VarnishService will expect to see a "<backendsFile>.tmpl" file in the ConfigMap that has the Go template for the <backendsFile>. For example, "backends.vcl.tmpl"
    backendsFile: backends.vcl
    # the name of the base VCL file
    defaultFile: default.vcl
  deployment:
    # The number of varnish instances to run
    replicas: 3
    varnishImage:
      # You might modify the host to be the nearest instance of container registry to the cluster
      host: registry.ng.bluemix.net
      # If you decide to host the varnish image yourself, you may need to change the image namespace or name
      # Note, however, that you cannot use any old version of varnish -- the official image has a sidecar process that monitors the kubernetes API
      namespace: icm-varnish
      name: varnish
      # You might specify a tag version to ensure that you control the lifecycle of what version of varnish is deployed
      tag: 2.0.5-a-dev
      # imagePullPolicy is passed directly to the varnish deployment, that controls how the varnish image will be pulled for new containers
      imagePullPolicy: Always
      # Name of the secret for the docker registry. The secret needs to exist in the namespace before creating this resource
      imagePullSecretName: docker-reg-secret
    # The amount of memory allocated to Varnish on Varnish's startup, in the form of `varnishd -F -s malloc,${varnishMemory} ...`
    varnishMemory: "1024M"
    # Resources allocated to the Varnish pod through Kubernetes. `requests.memory` should be greater than `varnishMemory` above
    varnishResources:
      limits:
        cpu: 1
        memory: "2048Mi"
      requests:
        cpu: 1
        memory: "2048Mi"
    # the restart policy for the varnish containers
    varnishRestartPolicy: Always
    # probe to determine liveness of the Varnish container. TODO: Not currently working
    # livenessProbe:
    #   httpGet:
    #     path: /liveness
    #     port: 8080
    # probe used to confirm readiness of the Varnish container. Unlikely to need to be changed, but can be either a command or an HTTP request
    readinessProbe:
      exec:
        command: [/usr/bin/varnishadm, ping]
      initialDelaySeconds: 5
    # Affinity to apply to the pods in the Varnish deployment. For more on affinity, see https://kubernetes.io/docs/concepts/configuration/assign-pod-node#affinity-and-anti-affinity
    # Also, see the README.md#affinites for suggested configurations
    affinity:
      # Keyword indicating that pods should repel each other based on the spec
      podAntiAffinity:
        # Keyword indicating that the anti-affinity should apply to all pods being scheduled from now on, but to leave currently running pods alone
        requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            # Apply the anti-affinity to all pods that match the following expression.
            # In this case, it finds pods with label "middleware: varnish".
            # All labels applied to the VarnishService are also applied to its dependent resources, including the Varnish deployment.
            matchExpressions:
            - key: middleware
              operator: In
              values:
              - varnish
          # This groups nodes according to the label key given. Technically any arbitrary label can be used for grouping, but there is a set of predefined labels on nodes that are almost always used.
          # Read https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#an-example-of-a-pod-that-uses-pod-affinity for a good explanation of topologyKey.
          topologyKey: "kubernetes.io/hostname"

    # Tolerations to apply to the pods in the Varnish deployment. For more on tolerations, see https://kubernetes.io/docs/concepts/configuration/taint-and-toleration  
    # Also, see the README.md#tolerations for suggested configurations
    # tolerations:
  # PodDisruptionBudgets allow you to tell Kubernetes how tolerant you are about pods going down due to administrative events, such node autoscaling or node upgrades.
  # For example, with "maxUnavailable: 0", any node drain events (possible during node autoscaling and upgrading) are not possible, because the budget does not allow for any pods to become unavailable.
  # For more information, see https://kubernetes.io/docs/concepts/workloads/pods/disruptions/ for information on what is considered a "disruption"
  # and https://kubernetes.io/docs/tasks/run-application/configure-pdb/ for more about PodDisruptionBudgets specifically.
  # NOTE: there should be ONLY ONE field under this spec. "selector" (part of the regular spec) is not needed here since it will automatically select the varnish pods, and "maxUnavailable" and "minAvailable" are mutually exclusive
  podDisruptionBudget:
    maxUnavailable: 0
    # minAvailable: 3

  # This is a regular service spec. For details on a service spec, see https://kubernetes.io/docs/concepts/services-networking/service
  # In the same way as you would with a vanilla service, choose a selector that targets a deployment. The resulting VarnishService will act like a regular Service, plus have Varnish caching.
  # WARNING: this service must ONLY expose a single port. Specifying multiple ports will result in an error
  service:
    selector:
      app: HttPerf
    ports:
    - port: 8080
      protocol: TCP
